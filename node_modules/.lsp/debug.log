Hello - from /home/p9romain/Téléchargements/Dev/ST3/rls-linux/reason-language-server
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 1, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","languageId":"ocaml","version":0,"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\n<<<<<<< HEAD\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n=======\ntype t =\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\n<<<<<<< HEAD\nlet rec pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t.descr with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll\n\n=======\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":10,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":10,"character":8},"end":{"line":10,"character":8}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":11,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":11,"character":15},"end":{"line":11,"character":15}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":4,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00810623168945ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":4,"character":0},"end":{"line":4,"character":12}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":1},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n=======\ntype t =\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\n<<<<<<< HEAD\nlet rec pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t.descr with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll\n\n=======\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":4,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":2},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n=======\ntype t =\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\n<<<<<<< HEAD\nlet rec pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t.descr with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll\n\n=======\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":3,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00691413879395ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":8,"character":1}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00715255737305ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":8,"character":1},"end":{"line":10,"character":69}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":8,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":8,"character":0},"end":{"line":10,"character":69}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":7,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":7,"character":14},"end":{"line":10,"character":69}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00381469726562ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":3},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\n<<<<<<< HEAD\nlet rec pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t.descr with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll\n\n=======\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":7,"character":14}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":56,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":56,"character":0},"end":{"line":56,"character":12}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00619888305664ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":5},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\nlet rec pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t.descr with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll\n\n=======\n>>>>>>> c3a4355 (Fix dependencies cycle : time to dig into the algo!)\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":55,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":85,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":85,"character":10},"end":{"line":85,"character":10}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":92,"character":22}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0119209289551ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":92,"character":22},"end":{"line":98,"character":69}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":54,"character":53}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0112056732178ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":54,"character":53},"end":{"line":98,"character":69}},"context":{"diagnostics":[],"triggerKind":2}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":6},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":54,"character":53}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00905990600586ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml","version":7},"contentChanges":[{"text":"open Format\nopen Stt\nmodule Name = Base.Hstring\n\nmodule Regexp = Tmp.Regexp\ntype regexp = Regexp.t_ext\n\ntype t_descr =\n    Printer of (formatter -> unit)\n  | Pair of t * t\n  | Arrow of t * t\n  | Cup of t list (* invariant cup/cap list have length >= 1 *)\n  | Cap of t list\n  | Diff of t * t\n  | Neg of t\n  | Regexp of Regexp.t_ext\n  (*  | Apply of Name.t * t list *)\n  | Rec of t * (Name.t * t) list\nand t = { typ : Typ.t ;\n          descr  : t_descr }\n\n\n\nmodule Prio : sig\n  type level = private int\n  val level : t -> level\n  val lowest : level\nend =\nstruct\n  type level = int\n  let lowest = 0\n  let level t = match t.descr with\n      Printer _ | Pair _ (* | Apply _ *) -> 10\n    | Neg _-> 9\n    | Cap _ | Diff _ -> 8\n    | Cup _ -> 7\n    | Arrow _ | Regexp _ -> 6\n    | Rec _ -> 5\nend\n\nlet mk typ descr = { typ; descr }\n\nlet var v =\n  let typ = Typ.var v in\n  mk typ (Printer (dprintf \"%a\" Var.pp v))\n\nlet name_descr v =\n  Printer (dprintf \"%s\" Name.(!!v))\n\nlet str_descr v =\n  Printer (dprintf \"%s\" v)\n\n\nlet any = mk Typ.any (Printer (dprintf \"Any\"))\nlet empty_ = mk Typ.empty (Printer (dprintf \"Empty\"))\n\nlet is_empty_comp (module M : Typ.Basic) t =\n  Typ.(is_empty (M.set (M.get t) empty))\n\nlet is_any_comp (module M : Typ.Basic) t =\n  let any_comp = M.set (M.get Typ.any) Typ.empty in\n  Typ.(subtype any_comp (M.set (M.get t) empty))\n\nlet choose_complement t =\n  let empty_comps = List.fold_left (fun acc b ->\n      let i =\n        match b with\n          Typ.Basic (module M)\n        | Typ.Constr ((module M), _) ->\n          if is_any_comp (module M) t then 1 else 0\n      in\n      acc + i\n    ) 0 Typ.all_components\n  in\n  empty_comps > Typ.num_components / 2\n\n\nmodule Vars = Base.Common.Pair (Var.Set) (Var.Set)\nmodule VarTable = Hashtbl.Make (Vars)\nmodule DescrTable = Hashtbl.Make (Typ)\nlet group_by_vars t =\n  let open Typ in\n  let var_table = VarTable.create 16 in\n  let get table key = try VarTable.find table key with Not_found -> empty in\n  let replace table key t = VarTable.replace table key t in\n  let update table key t = replace table key (cup t (get table key)) in\n  (* Group according to the DNF *)\n  List.iter (function Basic (module M) | Constr ((module M), _) ->\n      M.get t\n      |> M.dnf\n      |> Seq.iter (fun ((pos, neg), l) ->\n          let key = (Var.Set.of_list pos, Var.Set.of_list neg) in\n          update var_table key (M.set (M.leaf l) empty)\n        )\n    ) all_components;\n  var_table\n\nlet reduce_variables var_table =\n  (* assumes (pos <> neg) *)\n  let vdest = VarTable.create 16 in\n  let empty_key = Var.Set.(empty, empty) in\n  let update_empty t =\n    let s = try VarTable.find vdest empty_key with Not_found -> Typ.empty in\n    VarTable.replace vdest empty_key Typ.(cup t s)\n  in\n  let te = try VarTable.find var_table empty_key with Not_found -> Typ.empty in\n  VarTable.remove var_table empty_key;\n  VarTable.add vdest empty_key te;\n  VarTable.iter (fun ((pos, neg) as key) t1 ->\n      if not (VarTable.mem vdest key) then begin\n        try\n          let t2 = VarTable.find vdest (neg, pos) in\n          let i12 = Typ.cap t1 t2 in\n          if Typ.is_empty i12 then begin\n            VarTable.add vdest key t1;\n            VarTable.add vdest (neg, pos) t2;\n          end else begin\n            update_empty i12;\n            VarTable.add vdest key Typ.(diff t1 i12);\n            VarTable.add vdest (neg, pos) Typ.(diff t2 i12);\n          end\n        with Not_found -> VarTable.add vdest key t1\n      end) var_table;\n  let te = VarTable.find vdest empty_key in\n  if Typ.is_empty te then VarTable.remove vdest empty_key;\n  vdest\n\nlet split_variables t =\n  let table = group_by_vars t in\n  reduce_variables table\n\nlet is_any t = Typ.(subtype any t)\n\nlet pcap l = match l with\n    [] -> assert false\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cap t.typ acc) Typ.any l in\n    mk typ (Cap l)\n\nlet pcup l = match l with\n  | [] -> empty_\n  | [ t ] -> t\n  | _ ->\n    let typ = List.fold_left (fun acc t -> Typ.cup t.typ acc) Typ.empty l in\n    mk typ (Cup l)\n\n\nlet any_node = Typ.(node any)\nlet any_prod = mk Typ.(product any_node any_node) (Pair (any, any))\nlet any_arrow = mk Builtins.arrow (str_descr \"Arrow\")\n\nlet neg t =\n  mk (Typ.neg t.typ) (Neg t)\n\nlet prod t1 t2 =\n  mk Typ.(product (node t1.typ) (node t2.typ)) (Pair (t1, t2))\n\nlet get_leaf (type t) (module M : Typ.Basic with type Leaf.t = t) t =\n  match (M.get t |> M.dnf) () with\n    Seq.Nil -> M.Leaf.empty\n  | Seq.Cons((([], []), l), _ ) -> l\n  | _ -> assert false\n\nlet pbasic (module M : Typ.Basic) t acc =\n  let l = get_leaf (module M) t in\n  if M.Leaf.is_empty l then acc else (mk t (Printer (fun ppf -> M.Leaf.pp ppf l)))::acc\n\nlet rec_names = Array.map Name.cons [|\"X\"; \"Y\"; \"Z\"; \"T\"; \"U\"; \"V\"; \"W\"|]\nlet decompile t =\n  let memo = DescrTable.create 16 in\n  let name_id = ref 0 in\n  let get_name () =\n    let i = !name_id in\n    incr name_id;\n    let len = Array.length rec_names in\n    if i >= len then Name.cons (\"X\" ^ (string_of_int (i-len)))\n    else rec_names.(i)\n  in\n  let rec pr_descr t =\n    let descr = pr_descr_ t in\n    mk t descr\n  and pr_descr_ t =\n    match DescrTable.find memo t with\n    | Some (_, _, pname) -> pname\n    | None ->\n      let n = get_name () in\n      let pname = name_descr n in\n      DescrTable.replace memo t (Some (n, empty_, pname));\n      pname\n    | exception Not_found ->\n      DescrTable.add memo t None;\n      let var_table = split_variables t in\n      let acc, has_others  =\n        match VarTable.find_opt var_table Var.Set.(empty, empty) with\n          Some t -> if is_any t then [any], false else\n            begin\n              VarTable.remove var_table Var.Set.(empty, empty);\n              [ pr_choose_compl t ], true\n            end\n        | None -> [], true\n      in\n      let acc = if not has_others then acc else\n          VarTable.fold (fun (vpos, vneg) t acc ->\n              if Typ.is_empty t then acc else\n                let tacc = Var.Set.fold (fun v acc -> (var v) :: acc) vpos [] in\n                let tacc = Var.Set.fold (fun v acc -> (neg (var v)) :: acc) vneg tacc in\n                let tacc = if is_any t then tacc else (pr_choose_compl t) :: tacc in\n                (pcap (List.rev tacc)) :: acc)\n            var_table acc\n      in\n      let res = pcup acc in\n      match DescrTable.find memo t with\n        None -> DescrTable.remove memo t; res.descr\n      | Some (n, _, pname) ->\n        DescrTable.replace memo t (Some (n, res, pname)); res.descr\n  and pr_node n = pr_descr (Typ.descr n)\n  and pr_choose_compl t =\n    let do_complement = choose_complement t in\n    let t = if do_complement then Typ.neg t else t in\n    let res = pr_no_var t in\n    match res, do_complement with\n      [], false -> empty_\n    | [], true -> any\n    | l, false -> pcup l\n    | l, true -> let cl = pcup l in\n      mk Typ.(diff any cl.typ) (Diff (any, cl))\n  and pr_no_var t =\n    let open Typ in\n    let acc = [] in\n    let acc = pbasic (module VarEnum) t acc in\n    let acc = pbasic (module VarInt) t acc in\n    let acc = pbasic (module VarChar) t acc in\n    let acc = pbasic (module VarUnit) t acc in\n    let acc =\n      let tp = cap t @@ product (node any) (node any) in\n      if Typ.(is_any tp || is_empty tp) then\n        acc\n      else\n        let any_star =\n          let x = make () in\n          let p = product (node any) x in\n          let c = cup Builtins.nil p in\n          let () = def x c in\n          c\n        in\n        let ts = cap tp any_star in\n        if is_empty ts then\n          (* tp :: acc (?) *)\n          acc\n        else\n          (* Somewhere : diff tp ts :: acc (?) *)\n          Regexp (pr_regexp ts) :: acc\n    in\n    let acc = pr_constr (module VarProduct : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_prod pr_product_line t acc\n    in\n    let acc = pr_constr (module VarArrow : Basic with type Leaf.t = Product.t)\n        (module Product : Base.Sigs.Bdd with type t = Product.t\n                                         and type atom = Product.atom\n                                         and type Leaf.t = Product.Leaf.t)\n        any_arrow pr_arrow_line t acc\n    in\n    acc\n  and pr_regexp t =\n    (* \n\n      - Need to use pr_descr (why?)\n      - Be aware of variables (how to get rid of/ignore them?)\n\n      Need to rethink about the algo \n\n    *)\n    let open Automaton in\n    let auto = empty in\n    let state =\n      let s = ref ~-1 in\n      fun () -> incr s; !s\n    in\n    let init = state () in\n    let finals = ref [] in\n    let states = ref [(t, init)] in\n    let trans = ref [] in\n    let loop t q =\n      if Typ.subtype Builtins.nil t then\n        finals:= q :: !finals ;\n      states := (t, q) :: !states ;\n      ()\n    in\n    let () = loop t init in\n    let auto = add_states auto @@ List.map snd !states in\n    let auto = add_start auto init in\n    let auto = add_ends auto !finals in\n    let auto = add_transitions auto !trans in\n    Regexp.(simp_to_ext @@ to_regex_my auto)\n  and pr_constr (type t a l)\n      (module V : Typ.Basic with type Leaf.t = t)\n      (module C : Base.Sigs.Bdd with type t = t and type atom = a and type Leaf.t = l)\n      any pr_line t acc =\n    if is_empty_comp (module V) t then acc\n    else if is_any_comp (module V) t then any :: acc\n    else\n      (*let () = Format.eprintf \"Going to ARROW LINE CAUSE: %a is not empty\\n%!\"\n        Typ.pp (V.set (V.get t) Typ.empty) in*)\n      let dnf = get_leaf (module V) t in\n      C.dnf dnf\n      |> Seq.fold_left pr_line acc\n  and pr_product_line acc ((posp, negp), _) =\n    let posp =\n      let open Typ in\n      match posp with\n        [] -> any_prod\n      | [ (n1, n2)] ->\n        prod (pr_node n1) (pr_node n2)\n      | ( n1, n2) :: ll ->\n        let n1, n2 = List.fold_left (fun (t1, t2) (n1, n2) ->\n            (cap t1 (descr n1), cap t2 (descr n2))) (descr n1, descr n2) ll\n        in  prod (pr_descr n1) (pr_descr n2)\n    in\n    let negp = List.map (fun (n1, n2) -> prod (pr_node n1) (pr_node n2)) negp in\n    let res = match negp with\n        [] -> posp\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posp.typ cl.typ) (Diff(posp, cl))\n    in res :: acc\n  and pr_arrow_line acc ((posa, nega),_) =\n    (*Format.eprintf \"IN ARROW LINE\\n%!\"; *)\n    let arrow (n1, n2) =\n      let t = Typ.arrow n1 n2 in\n      mk t (Arrow (pr_node n1, pr_node n2))\n    in\n    let posa = List.map arrow posa in\n    let nega = List.map arrow nega in\n    let posa = match posa with [] -> any_arrow | l -> pcap l in\n    let res = match nega with\n        [] -> posa\n      | l ->\n        let cl = pcup l in\n        mk Typ.(diff posa.typ cl.typ) (Diff(posa, cl))\n    in\n    res :: acc\n  in\n  let res = pr_descr t in\n  let recs = DescrTable.fold (fun _ x acc ->\n      match x with\n        None -> acc\n      | Some (n, d, _) -> (n, d)::acc\n    ) memo []\n  in\n  match recs with\n    [] -> res\n  | _ -> mk t (Rec(res, recs))\n\nlet global_print_table = DescrTable.create 16\n\nlet rec pp fmt t =\n  let d = try DescrTable.find global_print_table t with\n      Not_found ->\n      let d = decompile t in\n      DescrTable.add global_print_table t d;\n      d\n  in\n  pr Prio.lowest fmt d ;\n\nand pr ?(assoc=true) parent_level  ppf t =\n  let level = Prio.level t in\n  let do_parens = level < parent_level ||\n                  (level = parent_level && not assoc)\n  in\n  fprintf ppf \"@[\";\n  if do_parens then fprintf ppf \"(\";\n  let () =\n    match t with\n      Printer f -> fprintf ppf \"%t\" f\n    | Pair (t1, t2) -> fprintf ppf \"(%a,@ %a)\" (pr level) t1 (pr level) t2\n    | Arrow (t1, t2) -> fprintf ppf \"%a@ ->@ %a\" (pr ~assoc:false level) t1 (pr level) t2\n    | Cup l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" |\" level) l\n    | Cap l -> fprintf ppf \"@[%a@]\" (pr_list_sep ~sep:\" &\" level) l\n    | Diff (t1, t2) -> fprintf ppf \"%a@ \\\\@ %a\" (pr level) t1 (pr ~assoc:false level) t2\n    | Neg t -> fprintf ppf \"~%a\" (pr level) t\n    | Regexp r -> fprintf ppf \"%s\" @@ Regexp.pp pp r\n    (*\n    | Apply (n, args) -> fprintf ppf \"%s (@[%a@])\" Name.(!!n) (pr_list_sep ~sep:\",\" Prio.lowest) args\n    *)\n    | Rec (t, defs) -> fprintf ppf \"%a@ where@ @[%a@]\" (pr level) t pr_defs defs\n  in\n  if do_parens then fprintf ppf \")\";\n  fprintf ppf \"@]\"\n\nand pr_list_sep ~sep level ppf l =\n  match l with\n    [] -> assert false\n  | t :: [] -> pr level ppf t\n  | t :: tl -> fprintf ppf \"%a%s@ \" (pr level) t sep;\n    pr_list_sep ~sep level ppf tl\n\nand pr_def ppf (x, t) =\n  fprintf ppf \"@[%s =@ %a@]\" Name.(!!x) (pr Prio.lowest) t\nand pr_defs ppf l =\n  match l with\n    [] -> assert false\n  | d :: [] -> pr_def ppf d\n  | d :: ll -> fprintf ppf \"%a@ and@ \" pr_def d;\n    pr_defs ppf ll"}]}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"position":{"line":55,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"}}}
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/p9romain/rp/cours/Stage/stt/syntax/pretty.ml"},"range":{"start":{"line":55,"character":0},"end":{"line":55,"character":0}},"context":{"diagnostics":[],"triggerKind":1,"only":["refactor","source"]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /home/p9romain/rp/cours/Stage/stt/syntax
]] Making a new jbuilder package at /home/p9romain/rp/cours/Stage/stt/syntax
=== Project root: /home/p9romain/rp/cours/Stage/stt
Detected `opam` dependency manager for local use
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/p9romain/rp/cours/Stage/stt/syntax/.merlin"}}
